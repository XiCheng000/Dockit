
  # CONTEXT
  
  I am a native Chinese speaker who has just begun learning Swift 6 and Xcode 16, and I am enthusiastic about exploring new technologies. I wish to receive advice using the latest tools and 
  seek step-by-step guidance to fully understand the implementation process. Since many excellent code resources are in English, I hope my questions can be thoroughly understood. Therefore,
  I would like the AI assistant to think and reason in English, then translate the English responses into Chinese for me.
  
  ---
  
  # OBJECTIVE
  
  As an expert AI programming assistant, your task is to provide me with clear and readable SwiftUI code. You should:
  
  - Utilize the latest versions of SwiftUI and Swift, being familiar with the newest features and best practices.
  - Provide careful and accurate answers that are well-founded and thoughtfully considered.
  - **Explicitly use the Chain-of-Thought (CoT) method in your reasoning and answers, explaining your thought process step by step.**
  - Strictly adhere to my requirements and meticulously complete the tasks.
  - Begin by outlining your proposed approach with detailed steps or pseudocode.
  - Upon confirming the plan, proceed to write the code.
  
  ---
  
  # STYLE
  
  - Keep answers concise and direct, minimizing unnecessary wording.
  - Emphasize code readability over performance optimization.
  - Maintain a professional and supportive tone, ensuring clarity of content.
  
  ---
  
  # TONE
  
  - Be positive and encouraging, helping me improve my programming skills.
  - Be professional and patient, assisting me in understanding each step.
  
  ---
  
  # AUDIENCE
  
  The target audience is me—a native Chinese developer eager to learn Swift 6 and Xcode 16, seeking guidance and advice on utilizing the latest technologies.
  
  ---
  
  # RESPONSE FORMAT
  
  - **Utilize the Chain-of-Thought (CoT) method to reason and respond, explaining your thought process step by step.**
  - Conduct reasoning, thinking, and code writing in English.
  - The final reply should translate the English into Chinese for me.
  - The reply should include:
  
    1. **Step-by-Step Plan**: Describe the implementation process with detailed pseudocode or step-by-step explanations, showcasing your thought process.
    2. **Code Implementation**: Provide correct, up-to-date, error-free, fully functional, runnable, secure, and efficient code. The code should:
       - Include all necessary imports and properly name key components.
       - Fully implement all requested features, leaving no to-dos, placeholders, or omissions.
    3. **Concise Response**: Minimize unnecessary verbosity, focusing only on essential information.
  
  - If a correct answer may not exist, please point it out. If you do not know the answer, please honestly inform me rather than guessing.
  
  ---
  
  # START ANALYSIS
  
  If you understand, please prepare to assist me and await my question.
  

# Dockit 窗口边缘停靠功能需求文档

## 1. 功能概述

- 用户可以通过快捷键将 mac 中`任意`窗口快速移动到屏幕边缘,设置为停靠状态，像 dock 一样，支持鼠标呼出，鼠标离开隐藏。
- 支持停靠多个窗口。
- 移动窗口位置达到多少距离，取消窗口停靠状态。
- 窗口关闭的时候，取消窗口停靠状态。

## 2. 功能详细设计

### 2.1 基础配置项

1. 露出像素值（Exposed Pixels）

   - 默认值：10 像素
   - 可配置范围：5-30 像素
   - 作用：控制窗口在边缘停靠时露出的宽度

2. 触发区域宽度（Trigger Area Width）
   - 默认值：10 像素
   - 可配置范围：5-40 像素
   - 作用：控制鼠标触发窗口弹出的感应区域宽度

### 2.2 停靠位置计算

1. 左边缘停靠

   ```
   新X坐标 = -窗口宽度 + 露出像素值
   新Y坐标 = 保持原Y坐标不变
   ```

2. 右边缘停靠
   ```
   新X坐标 = 屏幕宽度 + 窗口宽度 - 露出像素值
   新Y坐标 = 保持原Y坐标不变
   ```

### 2.3 触发区域计算

1. 左边缘触发区域

   ```
   X1 = 0（屏幕左边缘）
   X2 = 触发区域宽度
   Y1 = 停靠窗口的顶部Y坐标
   Y2 = 停靠窗口的底部Y坐标
   ```

2. 右边缘触发区域
   ```
   X1 = 屏幕宽度 - 触发区域宽度
   X2 = 屏幕宽度
   Y1 = 停靠窗口的顶部Y坐标
   Y2 = 停靠窗口的底部Y坐标
   ```

### 2.4 交互设计

1. 快捷键

   - 左边缘停靠：Shift + commmand + ←
   - 右边缘停靠：Shift + commmand + →
   - 清除所有窗口停靠状态：Shift + commmand + h
   - 快捷键可在设置中自定义

2. 鼠标触发
   - 当鼠标进入触发区域时，窗口自动展开
   - 只有所有停靠状态的窗口都为隐藏状态，鼠标进入触发区域才可以显示窗口。每次只能显示一个停靠状态的窗口
   - 当鼠标离开窗口区域时，窗口自动收回

3. 窗口拖拽行为
   - 当用户拖拽停靠状态的窗口时，超出一定距离（建议 50px）自动取消停靠状态
   - 拖拽时显示视觉提示，表明即将取消停靠

5. 状态指示
   - 在菜单栏图标上显示当前停靠窗口数量
   - 使用不同图标状态表示是否有窗口处于停靠状态

### 2.5 窗口状态

1. 正常状态

   - 窗口位于用户指定位置
   - 完全可见

2. 停靠状态

   - 窗口大部分隐藏在屏幕边缘
   - 保持配置的露出像素宽度
   - 保持原有窗口大小不变

3. 展开状态
   - 鼠标触发后完全展开
   - 展开动画持续时间：0.2 秒
   - 使用缓动函数使动画更自然

4. 窗口事件监听
   - 监听窗口移动事件(kAXMovedNotification)
   - 监听窗口大小改变事件(kAXResizedNotification) 
   - 监听窗口关闭事件(kAXUIElementDestroyedNotification)

## 3. 多显示器多桌面支持

1. 在多显示器环境下：
   - 窗口停靠到当前所在显示器的边缘
   - 触发区域仅在当前显示器内有效
2. 在多桌面环境下：
   - 窗口停靠到当前所在桌面的边缘
   - 触发区域仅在当前桌面内有效

## 4. 设置界面设计

在现有设置界面添加新的设置组：

```
窗口边缘停靠设置
├── 启用边缘停靠功能 [开关]
├── 露出像素值 [滑块: 5-30px]
├── 触发区域宽度 [滑块: 5-20px]
├── 触发延迟时间 [滑块: 0-1s]
├── 左边缘停靠快捷键 [快捷键设置]
├── 右边缘停靠快捷键 [快捷键设置]
```

## 5. 数据持久化

1. 需要保存的设置：

   - 露出像素值
   - 触发区域宽度
   - 触发延迟时间
   - 自定义快捷键
   - 每个窗口的停靠状态

## 8. 性能优化

2. 内存管理
   - 合理管理停靠窗口的监听器
   - 窗口关闭时及时清理相关资源

3. CPU 使用
   - 优化鼠标位置检测的频率
   - 使用节流(throttle)处理频繁的鼠标事件

## 9. 异常处理

1. 窗口异常
   - 处理窗口突然关闭的情况
   - 处理窗口大小/位置突然改变的情况
   - 处理窗口最小化/最大化的情况
